sdata$fin[nrow(sdata)] <- nrow(gdata)
} else if (wdata$fin[nrow(wdata)] == (n + 1)){
wdata$fin[nrow(wdata)] <- nrow(gdata)
} else {
stop("Error en la corrección intervalos adyacentes")
}
sdata$fin[nrow(sdata)] == (n + 1)
wdata$fin[nrow(wdata)] == (n + 1)
sdata
wdata
# --- sueño y wake data para el background (indices) -------------------------- #
sdata <- find.segment(semiperdf, st.edit, "S")
wdata <- find.segment(semiperdf, st.edit, "W")
# Solución por si no hay nada de sueño o vigilia
# (agrega 1 epoch falso al final) quitando un epoch al que tiene datos
if (nrow(wdata) == 0){
statusW <- FALSE
} else if (nrow(sdata) == 0){
statusS <- FALSE
} else {
statusW <- TRUE
statusS <- TRUE
}
# No hay vigilia, solo sueño
if (statusW == FALSE){
wdata[1,"ini"] <- sdata[nrow(sdata), "fin"]
wdata[1,"fin"] <- sdata[nrow(sdata), "fin"]
sdata[nrow(sdata), "fin"] <- sdata[nrow(sdata), 2] - 1
# No hay sueño, solo vigilia
} else if (statusS == FALSE){
sdata[1,"ini"] <- wdata[nrow(wdata), "fin"]
sdata[1,"fin"] <- wdata[nrow(wdata), "fin"]
wdata[nrow(wdata), "fin"] <- wdata[nrow(wdata), "fin"] - 1
}
# Queda un gap entre sueño y viglia porque queda 1 minuto (intervalo) blanco
# se agrega un minuto al final
n <- nrow(gdata)
sdata <- mutate(sdata, fin = fin + 1)
wdata <- mutate(wdata, fin = fin + 1)
sdata
wdata
# Dada la corrección se excede el último intervalo en S o W
if (sdata$fin[nrow(sdata)] == (n + 1)){
sdata$fin[nrow(sdata)] <- nrow(gdata)
} else if (wdata$fin[nrow(wdata)] == (n + 1)){
wdata$fin[nrow(wdata)] <- nrow(gdata)
} else {
stop("Error en la corrección intervalos adyacentes")
}
source('D:/OneDrive/INTA/Actigrafia/func_processAwd/create.plotActo.R', encoding = 'UTF-8', echo=TRUE)
gdata <- check.acvfilter(awdfile)
gdata <- gdata$semiper
windows()
create.actogram(gdata)
gdata <- check.acvfilter(awdfile)
gdata <- gdata$semiper
semiperdf <- gdata[1]
# ---- Data para los ejes ---------------------------------------------------- #
# Hora decimal continua
lim <- as.numeric(set$ininoc)/3600
semiperdf <- mutate(semiperdf, xscale = ifelse(hrdec < lim,  hrdec + 24, hrdec))
# semiperdf$xscale = ifelse(semiperdf$hrdec < lim,
#                           semiperdf$hrdec + 24,
#                           semiperdf$hrdec)
# X: Escala y etuquetas
xscale <- seq(as.numeric(set$ininoc)/3600, length.out = 25)
xlabel <- ifelse(xscale >= 48, xscale - 48,
ifelse(xscale >= 24, xscale - 24, xscale))
# Y: Lineas al inicio, dia, y fin
ylinea <- as.numeric(c(set$ininoc, set$inidia + hours(24),
set$ininoc + hours(24)))/3600
# Y: Limites
limY <-  c(0, ceiling(max(semiperdf$act.edit)/10)*10)
limY[2] <- limY[2] * pct.y
limX <- c(min(xscale), max(xscale))
# --- sueño y wake data para el background (indices) -------------------------- #
sdata <- find.segment(semiperdf, st.edit, "S")
wdata <- find.segment(semiperdf, st.edit, "W")
# Solución por si no hay nada de sueño o vigilia
# (agrega 1 epoch falso al final) quitando un epoch al que tiene datos
if (nrow(wdata) == 0){
statusW <- FALSE
} else if (nrow(sdata) == 0){
statusS <- FALSE
} else {
statusW <- TRUE
statusS <- TRUE
}
# No hay vigilia, solo sueño
if (statusW == FALSE){
wdata[1,"ini"] <- sdata[nrow(sdata), "fin"]
wdata[1,"fin"] <- sdata[nrow(sdata), "fin"]
sdata[nrow(sdata), "fin"] <- sdata[nrow(sdata), 2] - 1
# No hay sueño, solo vigilia
} else if (statusS == FALSE){
sdata[1,"ini"] <- wdata[nrow(wdata), "fin"]
sdata[1,"fin"] <- wdata[nrow(wdata), "fin"]
wdata[nrow(wdata), "fin"] <- wdata[nrow(wdata), "fin"] - 1
}
# Queda un gap entre sueño y viglia porque queda 1 minuto (intervalo) blanco
# se agrega un minuto al final
n <- nrow(gdata)
sdata <- mutate(sdata, fin = fin + 1)
wdata <- mutate(wdata, fin = fin + 1)
sdata
wdata
gdata <- check.acvfilter(awdfile)
gdata <- gdata$semiper
semiperdf <- gdata[[1]]
# ---- Data para los ejes ---------------------------------------------------- #
# Hora decimal continua
lim <- as.numeric(set$ininoc)/3600
semiperdf <- mutate(semiperdf, xscale = ifelse(hrdec < lim,  hrdec + 24, hrdec))
# semiperdf$xscale = ifelse(semiperdf$hrdec < lim,
#                           semiperdf$hrdec + 24,
#                           semiperdf$hrdec)
# X: Escala y etuquetas
xscale <- seq(as.numeric(set$ininoc)/3600, length.out = 25)
xlabel <- ifelse(xscale >= 48, xscale - 48,
ifelse(xscale >= 24, xscale - 24, xscale))
# Y: Lineas al inicio, dia, y fin
ylinea <- as.numeric(c(set$ininoc, set$inidia + hours(24),
set$ininoc + hours(24)))/3600
# Y: Limites
limY <-  c(0, ceiling(max(semiperdf$act.edit)/10)*10)
limY[2] <- limY[2] * pct.y
limX <- c(min(xscale), max(xscale))
# --- sueño y wake data para el background (indices) -------------------------- #
sdata <- find.segment(semiperdf, st.edit, "S")
wdata <- find.segment(semiperdf, st.edit, "W")
# Solución por si no hay nada de sueño o vigilia
# (agrega 1 epoch falso al final) quitando un epoch al que tiene datos
if (nrow(wdata) == 0){
statusW <- FALSE
} else if (nrow(sdata) == 0){
statusS <- FALSE
} else {
statusW <- TRUE
statusS <- TRUE
}
# No hay vigilia, solo sueño
if (statusW == FALSE){
wdata[1,"ini"] <- sdata[nrow(sdata), "fin"]
wdata[1,"fin"] <- sdata[nrow(sdata), "fin"]
sdata[nrow(sdata), "fin"] <- sdata[nrow(sdata), 2] - 1
# No hay sueño, solo vigilia
} else if (statusS == FALSE){
sdata[1,"ini"] <- wdata[nrow(wdata), "fin"]
sdata[1,"fin"] <- wdata[nrow(wdata), "fin"]
wdata[nrow(wdata), "fin"] <- wdata[nrow(wdata), "fin"] - 1
}
# Queda un gap entre sueño y viglia porque queda 1 minuto (intervalo) blanco
# se agrega un minuto al final
n <- nrow(gdata)
sdata <- mutate(sdata, fin = fin + 1)
wdata <- mutate(wdata, fin = fin + 1)
# ---- Data para los ejes ---------------------------------------------------- #
# Hora decimal continua
lim <- as.numeric(set$ininoc)/3600
semiperdf <- mutate(semiperdf, xscale = ifelse(hrdec < lim,  hrdec + 24, hrdec))
# semiperdf$xscale = ifelse(semiperdf$hrdec < lim,
#                           semiperdf$hrdec + 24,
#                           semiperdf$hrdec)
# X: Escala y etuquetas
xscale <- seq(as.numeric(set$ininoc)/3600, length.out = 25)
xlabel <- ifelse(xscale >= 48, xscale - 48,
ifelse(xscale >= 24, xscale - 24, xscale))
# Y: Lineas al inicio, dia, y fin
ylinea <- as.numeric(c(set$ininoc, set$inidia + hours(24),
set$ininoc + hours(24)))/3600
# Y: Limites
limY <-  c(0, ceiling(max(semiperdf$act.edit)/10)*10)
limY[2] <- limY[2] * pct.y
limX <- c(min(xscale), max(xscale))
# --- sueño y wake data para el background (indices) -------------------------- #
sdata <- find.segment(semiperdf, st.edit, "S")
wdata <- find.segment(semiperdf, st.edit, "W")
# Solución por si no hay nada de sueño o vigilia
# (agrega 1 epoch falso al final) quitando un epoch al que tiene datos
if (nrow(wdata) == 0){
statusW <- FALSE
} else if (nrow(sdata) == 0){
statusS <- FALSE
} else {
statusW <- TRUE
statusS <- TRUE
}
# No hay vigilia, solo sueño
if (statusW == FALSE){
wdata[1,"ini"] <- sdata[nrow(sdata), "fin"]
wdata[1,"fin"] <- sdata[nrow(sdata), "fin"]
sdata[nrow(sdata), "fin"] <- sdata[nrow(sdata), 2] - 1
# No hay sueño, solo vigilia
} else if (statusS == FALSE){
sdata[1,"ini"] <- wdata[nrow(wdata), "fin"]
sdata[1,"fin"] <- wdata[nrow(wdata), "fin"]
wdata[nrow(wdata), "fin"] <- wdata[nrow(wdata), "fin"] - 1
}
# Queda un gap entre sueño y viglia porque queda 1 minuto (intervalo) blanco
# se agrega un minuto al final
n <- nrow(gdata)
sdata <- mutate(sdata, fin = fin + 1)
wdata <- mutate(wdata, fin = fin + 1)
# ---- Data para los ejes ---------------------------------------------------- #
# Hora decimal continua
lim <- as.numeric(set$ininoc)/3600
semiperdf <- mutate(semiperdf, xscale = ifelse(hrdec < lim,  hrdec + 24, hrdec))
# semiperdf$xscale = ifelse(semiperdf$hrdec < lim,
#                           semiperdf$hrdec + 24,
#                           semiperdf$hrdec)
# X: Escala y etuquetas
xscale <- seq(as.numeric(set$ininoc)/3600, length.out = 25)
xlabel <- ifelse(xscale >= 48, xscale - 48,
ifelse(xscale >= 24, xscale - 24, xscale))
# Y: Lineas al inicio, dia, y fin
ylinea <- as.numeric(c(set$ininoc, set$inidia + hours(24),
set$ininoc + hours(24)))/3600
# Y: Limites
limY <-  c(0, ceiling(max(semiperdf$act.edit)/10)*10)
limY[2] <- limY[2] * pct.y
limX <- c(min(xscale), max(xscale))
xscale <- seq(as.numeric(set$ininoc)/3600, length.out = 25)
xlabel <- ifelse(xscale >= 48, xscale - 48,
ifelse(xscale >= 24, xscale - 24, xscale))
# Y: Lineas al inicio, dia, y fin
ylinea <- as.numeric(c(set$ininoc, set$inidia + hours(24),
set$ininoc + hours(24)))/3600
# Y: Limites
limY <-  c(0, ceiling(max(semiperdf$act.edit)/10)*10)
limY[2] <- limY[2] * pct.y
limX <- c(min(xscale), max(xscale))
sdata <- find.segment(semiperdf, st.edit, "S")
wdata <- find.segment(semiperdf, st.edit, "W")
sdata
wdata
if (nrow(wdata) == 0){
statusW <- FALSE
} else if (nrow(sdata) == 0){
statusS <- FALSE
} else {
statusW <- TRUE
statusS <- TRUE
}
nrow(wdata) == 0
# --- sueño y wake data para el background (indices) -------------------------- #
sdata <- find.segment(semiperdf, st.edit, "S")
wdata <- find.segment(semiperdf, st.edit, "W")
# Solución por si no hay nada de sueño o vigilia
# (agrega 1 epoch falso al final) quitando un epoch al que tiene datos
statusW <- TRUE
statusS <- TRUE
if (nrow(wdata) == 0){statusW <- FALSE}
if (nrow(sdata) == 0){statusS <- FALSE}
sdata <- find.segment(semiperdf, st.edit, "S")
wdata <- find.segment(semiperdf, st.edit, "W")
# Solución por si no hay nada de sueño o vigilia
# (agrega 1 epoch falso al final) quitando un epoch al que tiene datos
statusW <- TRUE
statusS <- TRUE
if (nrow(wdata) == 0){statusW <- FALSE}
if (nrow(sdata) == 0){statusS <- FALSE}
# No hay vigilia, solo sueño
if (statusW == FALSE){
wdata[1,"ini"] <- sdata[nrow(sdata), "fin"]
wdata[1,"fin"] <- sdata[nrow(sdata), "fin"]
sdata[nrow(sdata), "fin"] <- sdata[nrow(sdata), 2] - 1
}
# No hay sueño, solo vigilia
if (statusS == FALSE){
sdata[1,"ini"] <- wdata[nrow(wdata), "fin"]
sdata[1,"fin"] <- wdata[nrow(wdata), "fin"]
wdata[nrow(wdata), "fin"] <- wdata[nrow(wdata), "fin"] - 1
}
wdata
sdata
n <- nrow(gdata)
sdata <- mutate(sdata, fin = fin + 1)
wdata <- mutate(wdata, fin = fin + 1)
wdata
sdata
sdata$fin[nrow(sdata)] == (n + 1)
sdata$fin[nrow(sdata)]
(n + 1)
if (nrow(wdata) == 0){statusW <- FALSE} else {statusW <- TRUE}
if (nrow(sdata) == 0){statusS <- FALSE} else {statusS <- TRUE}
sdata <- find.segment(semiperdf, st.edit, "S")
wdata <- find.segment(semiperdf, st.edit, "W")
# Solución por si no hay nada de sueño o vigilia
# (agrega 1 epoch falso al final) quitando un epoch al que tiene datos
if (nrow(wdata) == 0){statusW <- FALSE} else {statusW <- TRUE}
if (nrow(sdata) == 0){statusS <- FALSE} else {statusS <- TRUE}
if (statusW == FALSE){    # No hay vigilia, solo sueño
wdata[1,"ini"] <- sdata[nrow(sdata), "fin"]
wdata[1,"fin"] <- sdata[nrow(sdata), "fin"]
sdata[nrow(sdata), "fin"] <- sdata[nrow(sdata), 2] - 1
}
if (statusS == FALSE){    # No hay sueño, solo vigilia
sdata[1,"ini"] <- wdata[nrow(wdata), "fin"]
sdata[1,"fin"] <- wdata[nrow(wdata), "fin"]
wdata[nrow(wdata), "fin"] <- wdata[nrow(wdata), "fin"] - 1
}
# Queda un gap entre sueño y viglia porque queda 1 minuto (intervalo) blanco
# se agrega un minuto al final
n <- nrow(semiperdf)
sdata <- mutate(sdata, fin = fin + 1)
wdata <- mutate(wdata, fin = fin + 1)
# Dada la corrección se excede el último intervalo en S o W
if (sdata$fin[nrow(sdata)] == (n + 1)){
sdata$fin[nrow(sdata)] <- nrow(gdata)
} else if (wdata$fin[nrow(wdata)] == (n + 1)){
wdata$fin[nrow(wdata)] <- nrow(gdata)
} else {
stop("Error en la corrección intervalos adyacentes")
}
# Sueño y wake data para el background (valores)
sdata <- mutate(sdata, ini = semiperdf$xscale[ini], fin = semiperdf$xscale[fin])
wdata <- mutate(wdata, ini = semiperdf$xscale[ini], fin = semiperdf$xscale[fin])
sdata <- find.segment(semiperdf, st.edit, "S")
wdata <- find.segment(semiperdf, st.edit, "W")
# Solución por si no hay nada de sueño o vigilia
# (agrega 1 epoch falso al final) quitando un epoch al que tiene datos
if (nrow(wdata) == 0){statusW <- FALSE} else {statusW <- TRUE}
if (nrow(sdata) == 0){statusS <- FALSE} else {statusS <- TRUE}
if (statusW == FALSE){    # No hay vigilia, solo sueño
wdata[1,"ini"] <- sdata[nrow(sdata), "fin"]
wdata[1,"fin"] <- sdata[nrow(sdata), "fin"]
sdata[nrow(sdata), "fin"] <- sdata[nrow(sdata), 2] - 1
}
if (statusS == FALSE){    # No hay sueño, solo vigilia
sdata[1,"ini"] <- wdata[nrow(wdata), "fin"]
sdata[1,"fin"] <- wdata[nrow(wdata), "fin"]
wdata[nrow(wdata), "fin"] <- wdata[nrow(wdata), "fin"] - 1
}
# Queda un gap entre sueño y viglia porque queda 1 minuto (intervalo) blanco
# se agrega un minuto al final
n <- nrow(semiperdf)
sdata <- mutate(sdata, fin = fin + 1)
wdata <- mutate(wdata, fin = fin + 1)
# Dada la corrección se excede el último intervalo en S o W
if (sdata$fin[nrow(sdata)] == (n + 1)){
sdata$fin[nrow(sdata)] <- nrow(gdata)
} else if (wdata$fin[nrow(wdata)] == (n + 1)){
wdata$fin[nrow(wdata)] <- nrow(gdata)
} else {
stop("Error en la corrección intervalos adyacentes")
}
# Sueño y wake data para el background (valores)
sdata <- mutate(sdata, ini = semiperdf$xscale[ini], fin = semiperdf$xscale[fin])
wdata <- mutate(wdata, ini = semiperdf$xscale[ini], fin = semiperdf$xscale[fin])
sdata <- find.segment(semiperdf, st.edit, "S")
wdata <- find.segment(semiperdf, st.edit, "W")
# Solución por si no hay nada de sueño o vigilia
# (agrega 1 epoch falso al final) quitando un epoch al que tiene datos
if (nrow(wdata) == 0){statusW <- FALSE} else {statusW <- TRUE}
if (nrow(sdata) == 0){statusS <- FALSE} else {statusS <- TRUE}
if (statusW == FALSE){    # No hay vigilia, solo sueño
wdata[1,"ini"] <- sdata[nrow(sdata), "fin"]
wdata[1,"fin"] <- sdata[nrow(sdata), "fin"]
sdata[nrow(sdata), "fin"] <- sdata[nrow(sdata), 2] - 1
}
if (statusS == FALSE){    # No hay sueño, solo vigilia
sdata[1,"ini"] <- wdata[nrow(wdata), "fin"]
sdata[1,"fin"] <- wdata[nrow(wdata), "fin"]
wdata[nrow(wdata), "fin"] <- wdata[nrow(wdata), "fin"] - 1
}
sdata
wdata
sdata <- find.segment(semiperdf, st.edit, "S")
wdata <- find.segment(semiperdf, st.edit, "W")
# Solución por si no hay nada de sueño o vigilia
# (agrega 1 epoch falso al final) quitando un epoch al que tiene datos
if (nrow(wdata) == 0){statusW <- FALSE} else {statusW <- TRUE}
if (nrow(sdata) == 0){statusS <- FALSE} else {statusS <- TRUE}
if (statusW == FALSE){    # No hay vigilia, solo sueño
wdata[1,"ini"] <- sdata[nrow(sdata), "fin"]
wdata[1,"fin"] <- sdata[nrow(sdata), "fin"]
sdata[nrow(sdata), "fin"] <- sdata[nrow(sdata), 2] - 1
}
if (statusS == FALSE){    # No hay sueño, solo vigilia
sdata[1,"ini"] <- wdata[nrow(wdata), "fin"]
sdata[1,"fin"] <- wdata[nrow(wdata), "fin"]
wdata[nrow(wdata), "fin"] <- wdata[nrow(wdata), "fin"] - 1
}
# Queda un gap entre sueño y viglia porque queda 1 minuto (intervalo) blanco
# se agrega un minuto al final
n <- nrow(semiperdf)
sdata <- mutate(sdata, fin = fin + 1)
wdata <- mutate(wdata, fin = fin + 1)
wdata
sdata
sdata$fin[nrow(sdata)]
# Dada la corrección se excede el último intervalo en S o W
if (sdata$fin[nrow(sdata)] == (n + 1)){
sdata$fin[nrow(sdata)] <- nrow(gdata)
} else if (wdata$fin[nrow(wdata)] == (n + 1)){
wdata$fin[nrow(wdata)] <- nrow(gdata)
} else {
stop("Error en la corrección intervalos adyacentes")
}
# --- sueño y wake data para el background (indices) -------------------------- #
sdata <- find.segment(semiperdf, st.edit, "S")
wdata <- find.segment(semiperdf, st.edit, "W")
# Solución por si no hay nada de sueño o vigilia
# (agrega 1 epoch falso al final) quitando un epoch al que tiene datos
if (nrow(wdata) == 0){statusW <- FALSE} else {statusW <- TRUE}
if (nrow(sdata) == 0){statusS <- FALSE} else {statusS <- TRUE}
if (statusW == FALSE){    # No hay vigilia, solo sueño
wdata[1,"ini"] <- sdata[nrow(sdata), "fin"]
wdata[1,"fin"] <- sdata[nrow(sdata), "fin"]
sdata[nrow(sdata), "fin"] <- sdata[nrow(sdata), 2] - 1
}
if (statusS == FALSE){    # No hay sueño, solo vigilia
sdata[1,"ini"] <- wdata[nrow(wdata), "fin"]
sdata[1,"fin"] <- wdata[nrow(wdata), "fin"]
wdata[nrow(wdata), "fin"] <- wdata[nrow(wdata), "fin"] - 1
}
# Queda un gap entre sueño y viglia porque queda 1 minuto (intervalo) blanco
# se agrega un minuto al final
n <- nrow(semiperdf)
sdata <- mutate(sdata, fin = fin + 1)
wdata <- mutate(wdata, fin = fin + 1)
# Dada la corrección se excede el último intervalo en S o W
if (sdata$fin[nrow(sdata)] == (n + 1)){
sdata$fin[nrow(sdata)] <- nrow(semiperdf)
} else if (wdata$fin[nrow(wdata)] == (n + 1)){
wdata$fin[nrow(wdata)] <- nrow(semiperdf)
} else {
stop("Error en la corrección intervalos adyacentes")
}
# Sueño y wake data para el background (valores)
sdata <- mutate(sdata, ini = semiperdf$xscale[ini], fin = semiperdf$xscale[fin])
wdata <- mutate(wdata, ini = semiperdf$xscale[ini], fin = semiperdf$xscale[fin])
gdata <- check.acvfilter(awdfile)
names(gdata)
semiper <- check.acvfilter(awdfile)
names(semiper)
semiper <- semiper$semiper
source('D:/OneDrive/INTA/Actigrafia/func_processAwd/create.plotActo.R', encoding = 'UTF-8', echo=TRUE)
source('D:/OneDrive/INTA/Actigrafia/mainScript.R', encoding = 'UTF-8', echo=TRUE)
awdfolder <- "D:/OneDrive/INTA/Actigrafia/testfolder/test_kansas"
setwd(awdfolder)
archivos <- dir()
archivos <- archivos[grep(".[Aa][Ww][Dd]$", archivos)]
awdfile <- "2058-010-310 NYU Visit3"
awdfile <- str_replace(awdfile, ".AWD", "")
# Cargar data para un grafico
semiper <- check.acvfilter(awdfile)
semiper <- semiper$semiper
semiperdf < semper$per00
semiperdf <- semperdf[[1]]
View(semiperdf)
otable("st.edit", data = semiperdf)
create.plotSimple(semiperdf)
awdfolder <- "D:/OneDrive/INTA/Actigrafia/testfolder/test_kansas"
setwd(awdfolder)
archivos <- dir()
archivos <- archivos[grep(".[Aa][Ww][Dd]$", archivos)]
awdfile <- "2058-010-310 NYU Visit3"
awdfile <- str_replace(awdfile, ".AWD", "")
# Cargar data para un grafico
semiper <- check.acvfilter(awdfile)
semiper <- semiper$semiper
semiperdf < semiper$per00
semiperdf <- semiperdf[[1]]
View(semiperdf)
otable("st.edit", data = semiperdf)
archivos <- archivos[grep(".[Aa][Ww][Dd]$", archivos)]
awdfile <- "2058-010-310 NYU Visit3"
awdfile <- str_replace(awdfile, ".AWD", "")
semiper <- check.acvfilter(awdfile)
semiper <- semiper$semiper
semiperdf < semiper$per00
names(semiper)
semiperdf <- semiper$per00
semiperdf <- semiperdf[[1]]
View(semiperdf)
otable("st.edit", data = semiperdf)
semiper <- check.acvfilter(awdfile)
semiper <- semiper$semiper
names(semiper)
semiperdf <- semiperdf[[1]]
View(semiperdf)
semiper <- check.acvfilter(awdfile)
semiper <- semiper$semiper
names(semiper)
semiperdf <- semiper$per00
View(semiperdf)
otable("st.edit", data = semiperdf)
windows()
create.actogram(semiper)
windows()
create.plotSimple(semiperdf)
windows()
create.plotActo(semiperdf)
source('D:/OneDrive/INTA/Actigrafia/mainScript.R', encoding = 'UTF-8', echo=TRUE)
awdfolder <- "D:/OneDrive/INTA/Actigrafia/testfolder/test_kansas"
setwd(awdfolder)
archivos <- dir()
archivos <- archivos[grep(".[Aa][Ww][Dd]$", archivos)]
awdfile <- "2058-010-310 NYU Visit3"
awdfile <- str_replace(awdfile, ".AWD", "")
semiper <- check.acvfilter(awdfile)
semiper <- semiper$semiper
windows()
create.actogram(semiper)
semiperdf <- semiper$per00
windows()
create.plotSimple(semiperdf)
windows()
create.plotActo(semiperdf)
source('D:/OneDrive/INTA/Actigrafia/mainScript.R', encoding = 'UTF-8', echo=TRUE)
runApp()
